<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Letter Builder v1.6-PWA</title>

<!-- XLSX + JSZip -->
<script src="xlsx.full.min.js"></script>
<script src="jszip.min.js"></script>

<style>
body { font-family: Calibri, sans-serif; margin: 40px; }
#logo { height: 40px; display: block; margin: auto; }
textarea { width: 100%; height: 150px; }
</style>
</head>
<body>

<img id="logo" src="logo.png">
<h2>Letter Builder v1.6-PWA</h2>

<input type="file" id="excelFile" accept=".xlsx"><br><br>

<label>To:</label><br>
<select id="toPerson"></select><br><br>

<label>From:</label><br>
<select id="fromPerson"></select><br><br>

<label>Letter Body:</label><br>
<textarea id="letterBody"></textarea><br><br>

<button onclick="generateDOCX()">Generate DOCX</button>

<script>
// ----------------------------------------------------
// GLOBAL MEMBER STORAGE
// ----------------------------------------------------
let members = [];

// Safe XML escape
const X = t => String(t ?? "")
  .replace(/&/g, "&amp;")
  .replace(/</g, "&lt;")
  .replace(/>/g, "&gt;");

// Wrap text as Word paragraph
const p = t => `<w:p><w:r><w:t>${t}</w:t></w:r></w:p>`;

// ----------------------------------------------------
// LOAD EXCEL
// ----------------------------------------------------
excelFile.addEventListener("change", e => {
    const r = new FileReader();
    r.onload = ev => {
        const wb = XLSX.read(new Uint8Array(ev.target.result), { type: "array" });
        members = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]]);
        loadDropdowns();
    };
    r.readAsArrayBuffer(e.target.files[0]);
});

function loadDropdowns() {
    toPerson.innerHTML = "";
    fromPerson.innerHTML = "";

    members.forEach((m, i) => {
        let lbl = (m["Last Name"] || "") + ", " +
                  (m["First Name"] || "") + " â€” " +
                  (m["Member ID"] || "");

        toPerson.innerHTML += `<option value="${i}">${lbl}</option>`;
        fromPerson.innerHTML += `<option value="${i}">${lbl}</option>`;
    });
}

function addr(m) {
    let a1 = m["Address 1"] || "";
    let a2 = m["Address 2"] || "";
    let merged = a2 ? a1 + ", " + a2 : a1;

    return [
        X(merged),
        X((m["City"] || "") + " " + (m["Province"] || "")),
        X((m["Country"] || "") + " " + (m["Postal Code"] || ""))
    ];
}

// ----------------------------------------------------
// GENERATE DOCX
// ----------------------------------------------------
async function generateDOCX() {

    const to = members[toPerson.value];
    const fr = members[fromPerson.value];
    const bodyLines = letterBody.value.split("\n").map(X);
    const dateStr = new Date().toLocaleDateString('en-US',
                    { year: "numeric", month: "long", day: "numeric" });

    // Load logo binary
    const logoBinary = await fetch("logo.png").then(r => r.arrayBuffer());

    // ------------------------------------------------
    // Build document.xml (WordprocessingML)
    // ------------------------------------------------
    let docXML =
`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
 xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"
 xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main"
 xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing"
 xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture">
<w:body>

<!-- Embedded Logo -->
<w:p><w:r><w:drawing>
  <wp:inline distT="0" distB="0" distL="0" distR="0">
    <wp:extent cx="2200000" cy="600000"/>
    <wp:docPr id="1" name="Logo"/>
    <a:graphic>
      <a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/picture">
        <pic:pic>
          <pic:blipFill>
            <a:blip r:embed="rId5"/>
          </pic:blipFill>
          <pic:spPr/>
        </pic:pic>
      </a:graphicData>
    </a:graphic>
  </wp:inline>
</w:drawing></w:r></w:p>

${p(X(dateStr))}
${p("To:")}
${p(X((to["First Name"]||"")+" "+(to["Last Name"]||"")))}
`;

    addr(to).forEach(l => docXML += p(l));
    docXML += p("Member ID: " + X(to["Member ID"] || ""));
    docXML += p("Next Payment Date: " + X(to["Next Payment Date"] ?? ""));

    docXML += p("From:");
    docXML += p(X((fr["First Name"]||"")+" "+(fr["Last Name"]||"")));

    addr(fr).forEach(l => docXML += p(l));

    docXML += p("Sincerely,");
    docXML += p(X(fr["First Name"] || "") + " " + X(fr["Last Name"] || ""));
    docXML += p("Email: " + X(fr["Email"] || ""));
    docXML += p("Home Phone: " + X(fr["Home Phone"] || ""));

    bodyLines.forEach(l => docXML += p(l));

    // REQUIRED sectPr block (fixes Word corruption)
    docXML +=
`<w:sectPr>
    <w:pgSz w:w="12240" w:h="15840"/>
    <w:pgMar w:top="1440" w:right="1440" w:bottom="1440" w:left="1440"/>
</w:sectPr>
</w:body></w:document>`;

    // ------------------------------------------------
    // ZIP PACKAGE (Docx)
    // ------------------------------------------------
    const zip = new JSZip();

    // [Content_Types].xml
    zip.file("[Content_Types].xml",
`<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Default Extension="png" ContentType="image/png"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
  <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>
  <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/>
</Types>`);

    // Root relationship
    zip.folder("_rels").file(".rels",
`<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
  <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>
  <Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/>
</Relationships>`);

    // Core metadata
    zip.folder("docProps").file("core.xml",
`<?xml version="1.0" encoding="UTF-8"?>
<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties"
 xmlns:dc="http://purl.org/dc/elements/1.1/">
  <dc:title>Letter v1.6</dc:title>
  <dc:creator>Letter Builder</dc:creator>
</cp:coreProperties>`);

    // REQUIRED app.xml (prevents Word opening error)
    zip.folder("docProps").file("app.xml",
`<?xml version="1.0" encoding="UTF-8"?>
<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties"
 xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">
  <Application>Letter Builder v1.6</Application>
  <DocSecurity>0</DocSecurity>
  <Pages>1</Pages>
  <Words>1</Words>
  <Characters>1</Characters>
</Properties>`);

    // Document
    zip.folder("word").file("document.xml", docXML);

    // Media
    zip.folder("word/media").file("logo.png", logoBinary);

    // Document relationships
    zip.folder("word/_rels").file("document.xml.rels",
`<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId5" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="media/logo.png"/>
</Relationships>`);

    // ------------------------------------------------
    // CREATE BLOB + DOWNLOAD WITH FILENAME PROMPT
    // ------------------------------------------------
    const defaultName = 
        `Letter_${(to["Last Name"]||"").replace(/ /g,"_")}_${new Date().toISOString().slice(0,10)}.docx`;

    const filename = prompt("Enter filename for DOCX:", defaultName) || defaultName;

    const blob = await zip.generateAsync({ type: "blob" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
}
</script>

</body>
</html>
